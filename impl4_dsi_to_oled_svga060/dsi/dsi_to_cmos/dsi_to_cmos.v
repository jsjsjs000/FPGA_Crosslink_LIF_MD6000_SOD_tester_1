//===========================================================================
// Verilog file generated by Clarity Designer    02/20/2024    12:51:05  
// Filename: dsi_to_cmos.v   IP package: D-PHY to CMOS 1.3
// Copyright(c) 2016 Lattice Semiconductor Corporation. All rights reserved. 
//===========================================================================

module dsi_to_cmos (
// Used only for internal testing
// reference clock and reset
  input           reset_n_i,

// DPHY interface 
  inout           clk_p_i,
  inout           clk_n_i,
  inout           d0_p_io,
  inout           d0_n_io,
  inout           d1_p_i,
  inout           d1_n_i,
  inout           d2_p_i,
  inout           d2_n_i,
  inout           d3_p_i,
  inout           d3_n_i,
// Pixel clock, control, and data
  output          clk_pixel_o,   // center aligned
  output          vsync_o,
  output          hsync_o,
  output          de_o,
  output [7:0]    pd_red_o,
  output [7:0]    pd_green_o,
  output [7:0]    pd_blue_o
);

///// Parameter Setting used by DPHY2CMOS IP /////
  localparam NUM_RX_LANE = 4;

  localparam RX_TYPE = "DSI";

  localparam DATA_TYPE = "RGB888";

  localparam RX_CLK_MODE = "HS_ONLY";

  localparam TX_WAIT_TIME = "LESS_15MS";

//added to integrate soft logic for SoT pattern detection to hard dphy
  localparam WORD_ALIGN = "ON";

  localparam LANE_ALIGN = "ON";

// Lane aligner FIFO depth
parameter FIFO_DEPTH   = 16;
// Lane aligner FIFO type for lane 0
parameter FIFO_TYPE0   = "EBR";
// Lane aligner FIFO type for lane 1
parameter FIFO_TYPE1   = "EBR";
// Lane aligner FIFO type for lane 2
parameter FIFO_TYPE2   = "EBR";
// Lane aligner FIFO type for lane 3
parameter FIFO_TYPE3   = "EBR";

  localparam BYTECLK_MHZ = 30.0000;

  localparam RX_GEAR = 8;

// This is for setting 2:1 Tx interface, does not set NUM_TX_CH parameter of DPHY2CMOS IP
  localparam NUM_TX_CH = 1;

// Pixel data bus width
localparam PD_BUS_WIDTH = ((DATA_TYPE == "RAW8")            || 
                           (DATA_TYPE == "YUV420_8")        || 
                           (DATA_TYPE == "LEGACY_YUV420_8") || 
                           (DATA_TYPE == "YUV420_8_CSPS")   || 
                           (DATA_TYPE == "YUV422_8"))          ? 8 :
                          ((DATA_TYPE == "RAW10")           || 
                           (DATA_TYPE == "YUV420_10")       || 
                           (DATA_TYPE == "YUV420_10_CSPS")  || 
                           (DATA_TYPE == "YUV422_10"))         ? 10 :
                           (DATA_TYPE == "RAW12")              ? 12 :
                          ((DATA_TYPE == "RGB666")          ||
                           (DATA_TYPE == "RGB666_LOOSE"))      ? 18 :
                                                                 24 ; 

localparam PD_BUS_WIDTH_DPHY2CMOS = PD_BUS_WIDTH * NUM_TX_CH;

// Pixel data width including extra bits in DPHY format
localparam PD_BUS_WIDTH_RX = (DATA_TYPE == "RGB666_LOOSE") ? 24 : PD_BUS_WIDTH;

reg                     reset_ref_n_meta, reset_ref_n_sync;
reg                     reset_byte_n_meta, reset_byte_n_sync;
reg                     reset_byte_fr_n_meta, reset_byte_fr_n_sync;
reg                     reset_pixel_n_meta, reset_pixel_n_sync;

wire                    pll_lock /* synthesis syn_keep=1 */; 
wire                    reset_byte_fr_n;
wire                    clk_byte;
wire                    clk_byte_fr /* synthesis syn_keep=1 */, clk_byte_fr_o;
wire                    clk_pixel /* synthesis syn_keep=1 */;
wire                    vsync, hsync, de;
wire                    fv, lv;
wire [PD_BUS_WIDTH_DPHY2CMOS-1:0] pd; // Supported PP_NUM_TX_CH_2

wire                    clk_pixel_pll;

wire                    refclk; //oscclk


///// Debug ports /////
// Used only for internal testing
wire [1:0]  lp_hs_state_clk, lp_hs_state_d;
wire        hs_clk_en, hs_d_en;
wire        hs_sync;
wire        capture_en;
wire        sp_en, lp_en, lp_av_en, payload_en;
wire [5:0]  dt;
wire [15:0] wc;
wire [3:0]  write_cycle;
wire        mem_we, mem_re;
wire [2:0]  mem_radr; 

wire        scuba_vhi;

/*synthesis translate_off*/
  GSR GSR_INST (.GSR (1'b1));  // only for simulation purposes
// not included in official release, only used to check for compile errors
/*synthesis translate_on*/

///// DPHY to CMOS Soft IP /////
    dsi_to_cmos_dphy_2_cmos_ip #(
        .RX_TYPE                (RX_TYPE),
        .TX_TYPE                ("CMOS"),
        .NUM_RX_LANE            (NUM_RX_LANE),
        .RX_GEAR                (RX_GEAR),
        .DPHY_RX_IP             ("MIXEL"),
        .DATA_TYPE              (DATA_TYPE),
        .NUM_TX_CH              (1),
        .PD_BUS_WIDTH           (PD_BUS_WIDTH_DPHY2CMOS),
        .RX_CLK_MODE            (RX_CLK_MODE),
        .TX_WAIT_TIME           (TX_WAIT_TIME),
        .LANE_ALIGN             (LANE_ALIGN),
        .WORD_ALIGN             (WORD_ALIGN),
        .BYTECLK_MHZ            (BYTECLK_MHZ),
        .FIFO_DEPTH             (FIFO_DEPTH),
        .FIFO_TYPE0             (FIFO_TYPE0),
        .FIFO_TYPE1             (FIFO_TYPE1),
        .FIFO_TYPE2             (FIFO_TYPE2),
        .FIFO_TYPE3             (FIFO_TYPE3)
        
    )
    dphy_2_cmos (
        .reset_n_i              (reset_n_i),
        .reset_lp_n_i           (reset_ref_n_sync),
        .reset_byte_n_i         (reset_n_i),
        .reset_byte_fr_n_i      (reset_byte_fr_n_sync),
        .reset_pixel_n_i        (reset_pixel_n_sync),
//#ifdef PP_RX_CLK_MODE_HS_LP
//        .clk_lp_ctrl_i          (refclk_i),  // external clock
//#endif
//#ifdef PP_RX_CLK_MODE_HS_ONLY
        .clk_lp_ctrl_i          (refclk),  // internal OSC clock
//#endif
        .clk_byte_fr_i          (clk_byte_fr),
        .clk_pixel_i            (clk_pixel),
        .pll_lock_i             (pll_lock),

        .clk_p_i                (clk_p_i),
        .clk_n_i                (clk_n_i),
        .d0_p_io                (d0_p_io),
        .d0_n_io                (d0_n_io),
        .d0_p_i                 (),
        .d0_n_i                 (),
        .d1_p_i                 (d1_p_i),
        .d1_n_i                 (d1_n_i),
        .d2_p_i                 (d2_p_i),
        .d2_n_i                 (d2_n_i),
        .d3_p_i                 (d3_p_i),
        .d3_n_i                 (d3_n_i),
        .clk_byte_o             (clk_byte),
        .clk_byte_fr_o          (clk_byte_fr_o),    // used only in HS_ONLY mode

        .lp_d0_rx_p_o           (),
        .lp_d0_rx_n_o           (),
        .lp_d1_rx_p_o           (),
        .lp_d1_rx_n_o           (),
        .lp_d2_rx_p_o           (),
        .lp_d2_rx_n_o           (),
        .lp_d3_rx_p_o           (),
        .lp_d3_rx_n_o           (),
        .cd_d0_o                (),
        .lp_d0_tx_en_i          (1'b0),
        .lp_d0_tx_p_i           (1'b0),
        .lp_d0_tx_n_i           (1'b0),

        .bd0_o                  (),                 // DSI to DSI only
        .bd1_o                  (),                 // DSI to DSI only
        .bd2_o                  (),                 // DSI to DSI only
        .bd3_o                  (),                 // DSI to DSI only

        .bd_o                   (),                 // CSI2 to CSI2 only
        .sp_en_o                (sp_en),            // CSI2 to CSI2 only
        .lp_en_o                (lp_en),            // CSI2 to CSI2 only
        .dt_o                   (dt),               // Debug/Customer use only
        .vc_o                   (),                 // CSI2 to CSI2 only
        .wc_o                   (wc),               // CSI2 to CSI2 only
        .ecc_o                  (),                 // Debug/Customer use only

        .vsync_o                (vsync),
        .hsync_o                (hsync),
        .de_o                   (de),
        .pd_o                   (pd),
        .fv_o                   (fv),               // CSI2 to CMOS only
        .lv_o                   (lv),               // CSI2 to CMOS only
        .p_odd_o                (),                 // DSI to FPD-LINK RGB888 GEAR16 only

        .lp_hs_state_clk_o      (lp_hs_state_clk),  // Debug only
        .term_clk_en_o          (term_clk_en),      // Debug only
        .lp_hs_state_d_o        (lp_hs_state_d),    // Debug only
        .hs_d_en_o              (hs_d_en),          // Debug only, could be used in DSI to DSI?
        .hs_sync_o              (hs_sync),          // Debug only
        .capture_en_o           (capture_en),       // Debug only
        .sp2_en_o               (),                 // Debug/Customer use only
        .lp2_en_o               (),                 // Debug/Customer use only
        .dt2_o                  (),                 // Debug/Customer use only
        .lp_av_en_o             (lp_av_en),         // Debug/Customer use only
        .lp2_av_en_o            (),                 // Debug/Customer use only
        .vc2_o                  (),                 // Debug/Customer use only
        .wc2_o                  (),                 // Debug/Customer use only
        .ecc2_o                 (),                 // Debug/Customer use only
        .payload_en_o           (payload_en),       // Debug only
        .write_cycle_o          (write_cycle),      // Debug only
        .mem_we_o               (mem_we),           // Debug only
        .mem_re_o               (mem_re),           // Debug only
        .read_cycle_o           (),                 // Debug only
        .mem_radr_o             (mem_radr)          // Debug only
    );

///// Synchronized Reset for each clock domain /////
//#ifdef PP_RX_CLK_MODE_HS_LP
//    always @(posedge refclk_i or negedge reset_n_i)
//#endif
//#ifdef PP_RX_CLK_MODE_HS_ONLY
    always @(posedge refclk or negedge reset_n_i)
//#endif
    begin
        if (~reset_n_i)
        begin
            reset_ref_n_meta <= 0;
            reset_ref_n_sync <= 0;
        end
        else
        begin
            reset_ref_n_meta <= reset_n_i;
            reset_ref_n_sync <= reset_ref_n_meta;
        end
    end

    always @(posedge clk_byte or negedge reset_n_i)
    begin
        if (~reset_n_i)
        begin
            reset_byte_n_meta <= 0;
            reset_byte_n_sync <= 0;
        end
        else
        begin
            reset_byte_n_meta <= reset_n_i;
            reset_byte_n_sync <= reset_byte_n_meta;
        end
    end

    assign reset_byte_fr_n = (RX_CLK_MODE == "HS_ONLY") ? reset_n_i : (reset_n_i & pll_lock);

    always @(posedge clk_byte_fr or negedge reset_n_i)
    begin
        if (~reset_n_i)
        begin
            reset_byte_fr_n_meta <= 0;
            reset_byte_fr_n_sync <= 0;
        end
        else
        begin
            reset_byte_fr_n_meta <= reset_byte_fr_n;
            reset_byte_fr_n_sync <= reset_byte_fr_n_meta;
        end
    end

    always @(posedge clk_pixel or negedge reset_n_i)
    begin
        if (~reset_n_i)
        begin
            reset_pixel_n_meta <= 0;
            reset_pixel_n_sync <= 0;
        end
        else
        begin
            reset_pixel_n_meta <= reset_n_i & pll_lock;
            reset_pixel_n_sync <= reset_pixel_n_meta;
        end
    end

///// OSC Instantiation using Sapphire in case of HS_ONLY /////
//generate
//    if (RX_CLK_MODE == "HS_ONLY")
            VHI scuba_vhi_inst (.Z(scuba_vhi));

            OSCI #(
                .HFCLKDIV (1)
            )
	        osc (
                .HFOUTEN  (scuba_vhi),
                .HFCLKOUT (refclk),  // ~47.6MHz by sim.
                .LFCLKOUT ()
            );
//endgenerate

///// PLL Instantiation /////
generate
  if ((PD_BUS_WIDTH == 8) & (NUM_RX_LANE == 1))
    if (RX_CLK_MODE == "HS_ONLY") begin 
      // special case: no need for pll since pixel clock = byte clock
      assign clk_pixel   = clk_byte_fr_o;
      assign clk_byte_fr = clk_byte_fr_o;
      assign pll_lock    = 1'b1;
    end
    else begin
      // special case: no need for clkos since pixel clock = byte clock
      pll_wrapper snow_pll_wrapper_inst ( 
        .CLKI              (refclk_i),
        .CLKOP             (clk_pixel_pll),
        .LOCK              (pll_lock)
      );
      assign clk_pixel   = clk_pixel_pll;
      assign clk_byte_fr = clk_pixel_pll;
    end
  else if (RX_CLK_MODE == "HS_ONLY") begin
    pll_wrapper snow_pll_wrapper_inst ( 
      .CLKI              (clk_byte_fr_o),
      .CLKOP             (clk_pixel),
      .LOCK              (pll_lock)
    );
    assign clk_byte_fr = clk_byte_fr_o;
  end
  else begin
    wire clkop_w, clkos_w;
    pll_wrapper snow_pll_wrapper_inst ( 
      .CLKI              (refclk_i),
      .CLKOP             (clkop_w),
      .CLKOS             (clkos_w), 
      .LOCK              (pll_lock)
      );
     if (DATA_TYPE == "RGB666") begin
       assign clk_pixel     = clkos_w;
       assign clk_byte_fr   = clkop_w;
     end
     else begin
       assign clk_pixel     = clkop_w;
       assign clk_byte_fr   = clkos_w;
     end

  end
endgenerate

// Support 2:1 Tx interface to achieve max 300 MHz Pixel clock output
///// Center-aligned Pixel Clock output by DDR output FF /////
    ODDRX1F pclk_ddr
    (
        .D0    (1'b0),
        .D1    (1'b1),
        .SCLK  (clk_pixel),
        .RST   (~reset_pixel_n_sync),
        .Q     (clk_pixel_o)
    );

///// CMOS Output Signals are latched by output FF /////
        OFS1P3DX vsync_ff
        (
            .D     (vsync),
            .SP    (1'b1),
            .SCLK  (clk_pixel),
            .CD    (~reset_pixel_n_sync),
            .Q     (vsync_o)
        );

        OFS1P3DX hsync_ff
        (
            .D     (hsync),
            .SP    (1'b1),
            .SCLK  (clk_pixel),
            .CD    (~reset_pixel_n_sync),
            .Q     (hsync_o)
        );

        OFS1P3DX de_ff
        (
            .D     (de),
            .SP    (1'b1),
            .SCLK  (clk_pixel),
            .CD    (~reset_pixel_n_sync),
            .Q     (de_o)
        );

genvar i;

    generate
        if ((DATA_TYPE == "RGB888") || (DATA_TYPE == "RGB666") || (DATA_TYPE == "RGB666_LOOSE"))
        begin
            for (i=0; i<PD_BUS_WIDTH/3 ;i=i+1)
            begin : red_ff
                OFS1P3DX r_ff_i
                (
                    .D     (pd[PD_BUS_WIDTH*2/3+i]),
                    .SP    (1'b1),
                    .SCLK  (clk_pixel),
                    .CD    (~reset_pixel_n_sync),
                    .Q     (pd_red_o[i])
                );
            end

            for (i=0; i<PD_BUS_WIDTH/3 ;i=i+1)
            begin : green_ff
                OFS1P3DX g_ff_i
                (
                    .D     (pd[PD_BUS_WIDTH/3+i]),
                    .SP    (1'b1),
                    .SCLK  (clk_pixel),
                    .CD    (~reset_pixel_n_sync),
                    .Q     (pd_green_o[i])
                );
            end

            for (i=0; i<PD_BUS_WIDTH/3 ;i=i+1)
            begin : blue_ff
                OFS1P3DX b_ff_i
                (
                    .D     (pd[i]),
                    .SP    (1'b1),
                    .SCLK  (clk_pixel),
                    .CD    (~reset_pixel_n_sync),
                    .Q     (pd_blue_o[i])
                );
            end
        end
    endgenerate

// Used only for internal testing

endmodule
